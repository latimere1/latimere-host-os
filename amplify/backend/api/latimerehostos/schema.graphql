##############################################################################
# Latimere Host OS — GraphQL schema (Valid for Amplify push)
# - Preserves existing models & auth
# - Adds Autopilot v0 graph + Decision Log
# - Adds Community Hub (Q&A/forum) models, tags, voting, accepted answers
# - Logging hooks annotated as comments (safe for push)
##############################################################################

############################
# Existing Models (untouched structure; minor IAM read added only where needed)
############################

type Property @model @auth(rules: [
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
  { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
  { allow: private, provider: iam, operations: [read] } # allow workers to read
]) {
  id: ID!
  name: String!
  address: String!
  sleeps: Int!
  owner: String!
  units: [Unit] @hasMany(indexName: "byProperty", fields: ["id"])
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Unit @model @auth(rules: [
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
  { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
  { allow: private, provider: iam, operations: [read] } # allow workers to read units
]) {
  id: ID!
  name: String!
  sleeps: Int!
  price: Float
  icalURL: String
  owner: String!
  propertyID: ID! @index(name: "byProperty", sortKeyFields: ["name"])
  bookings: [Booking] @hasMany(indexName: "byUnit", fields: ["id"])

  # --- Autopilot-friendly metadata (optional) ---
  timezone: String
  bedrooms: Int
  bathrooms: Float
  baseRate: Float
  minStay: Int
  policies: [PolicyRef]         # references to Policy records for this unit

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Booking @model @auth(rules: [
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
  { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
  { allow: private, provider: iam, operations: [read] } # allow workers to read bookings
]) {
  id: ID!
  guestName: String
  checkIn: AWSDate!
  checkOut: AWSDate!
  payout: Float
  owner: String!
  unitID: ID! @index(name: "byUnit", sortKeyFields: ["checkIn"])

  # --- Helpful for Autopilot routing/metrics (optional) ---
  channel: String        # airbnb|direct|vrbo
  status: String         # confirmed|cancelled|hold
  guestEmail: AWSEmail

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Cleaning @model @auth(rules: [
  { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
  { allow: owner, ownerField: "assignedTo", identityClaim: "cognito:username", operations: [read, update] },
  { allow: private, provider: iam, operations: [read, update] } # workers may update status
]) {
  id: ID!
  unitID: ID!
  date: AWSDateTime!
  status: String!
  assignedTo: String!
  notes: String
  owner: String!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type UserProfile @model @auth(rules: [
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update] },
  { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
]) {
  id: ID!
  username: String!
  role: String!
  hasPaid: Boolean!
  owner: String!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type RevenueRecord @model @auth(rules: [
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
  { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] },
  { allow: private, provider: iam, operations: [read] } # allow workers to read revenue baselines
]) {
  id: ID!
  unitID: ID!
  amount: Float!
  month: String!
  owner: String!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type CleanerAffiliation @model @auth(rules: [
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
  { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
]) {
  id: ID!
  owner: String! @index(name: "byOwner", queryField: "listAffiliationsByOwner")
  cleanerUsername: String! @index(name: "byCleaner", queryField: "listAffiliationsByCleaner")
  cleanerDisplay: String
  status: String!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Invitation @model @auth(rules: [
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
  { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
]) {
  id: ID!
  owner: String! @index(name: "byOwnerInvites", queryField: "listInvitationsByOwner")
  email: String! @index(name: "byEmailInvites", queryField: "listInvitationsByEmail")
  role: String!
  tokenHash: String!
  status: String!
  lastSentAt: AWSDateTime
  expiresAt: AWSDateTime!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type InboxThread
  @model(
    queries: { get: "getInboxThread", list: "listInboxThreads" }
    mutations: { create: "createInboxThread", update: "updateInboxThread", delete: "deleteInboxThread" }
  )
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read, update] }
  ])
{
  id: ID!
  maskedEmail: String! @index(name: "byMaskedEmail", queryField: "inboxThreadsByMaskedEmail")
  subject: String
  lastMessageAt: AWSDateTime
  messages: [InboxMessage] @hasMany(indexName: "byThread", fields: ["id"])
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type InboxMessage
  @model(
    queries: { get: "getInboxMessage", list: "listInboxMessages" }
    mutations: { create: "createInboxMessage", update: "updateInboxMessage", delete: "deleteInboxMessage" }
    subscriptions: null
  )
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read] }
  ])
{
  id: ID!
  threadId: ID! @index(name: "byThread", sortKeyFields: ["createdAt"])
  from: String
  to: String
  subject: String
  body: String
  messageId: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

############################
# NEW — Autopilot v0 Graph
############################

# Lightweight ref so Unit can list its active policies without embedding all config
type PolicyRef {
  id: ID!
  type: String!
}

# Policy holds pricing/min-stay/gap-fill configs per Unit
type Policy @model @auth(rules: [
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
  { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
  { allow: private, provider: iam, operations: [read] } # workers read policies
]) {
  id: ID!
  unitID: ID! @index(name: "byUnit", sortKeyFields: ["type"])
  type: String!          # pricing|min_stay|gap_fill|other
  config: AWSJSON!       # e.g. tiers, weekends, gap rules
  enabled: Boolean!
  owner: String!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# NightlyRate stores proposed/applied rates per unit per night
type NightlyRate @model @auth(rules: [
  { allow: private, provider: iam, operations: [create, read, update] }, # workers write/read
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [read] },
  { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
]) {
  id: ID!
  unitID: ID! @index(name: "byUnitDate", sortKeyFields: ["date"], queryField: "ratesByUnitDate")
  date: AWSDate!
  state: String!         # proposed|applied
  price: Float!
  reason: String         # short explanation (e.g., "leadTier:14 gap:2 weekend")
  details: AWSJSON       # full inputs for audit
  owner: String!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# Turn = operational job for cleans (separate from existing Cleaning for Autopilot control)
type Turn @model @auth(rules: [
  { allow: private, provider: iam, operations: [create, read, update] }, # workers schedule/update
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
  { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] }
]) {
  id: ID!
  unitID: ID! @index(name: "byUnitStart", sortKeyFields: ["startDate"], queryField: "turnsByUnitStart")
  bookingId: ID
  startDate: AWSDateTime!
  endDate: AWSDateTime!
  status: String!            # scheduled|confirmed|in_progress|done|reclean_needed|cancelled
  assignedToVendorId: ID
  photos: [AWSURL!]
  notes: String
  owner: String!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# Vendor network entity for cleaners/handymen with basic scoring
type Vendor @model @auth(rules: [
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
  { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
  { allow: private, provider: iam, operations: [read] } # workers select vendors
]) {
  id: ID!
  kind: String!               # cleaner|handyman
  name: String!
  phone: String
  score: Float                # on-time/quality blended
  costIndex: Float            # relative cost
  serviceAreas: [String!]     # zips/tags
  owner: String!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# Decision Log — every automated/human action with reason + details
type ActionLog @model
@auth(rules: [
  { allow: private, provider: iam, operations: [create, read] },     # workers write logs, services read
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [read] },
  { allow: groups, groups: ["admin", "Admins"], operations: [read, delete] }
]) {
  id: ID!
  unitID: ID! @index(name: "byUnitTime", sortKeyFields: ["createdAt"], queryField: "actionLogByUnitTime")
  actor: String!              # autopilot|human|system
  action: String!             # price_set|turn_assigned|msg_sent|...
  reason: String              # one-line why
  details: AWSJSON            # inputs/outputs snapshot
  createdAt: AWSDateTime!
  owner: String!
}

############################
# NEW — Community Hub (Q&A/Forum)
############################

# NOTE: To maximize SEO and traffic later, you may enable public read by adding:
# { allow: public, operations: [read] }
# to Post/Answer/Comment auth rules, *after* you enable an API key or Lambda auth.
# For now, rules mirror your private/owner/groups pattern; plus IAM-read so SSR works.

enum PostType { QUESTION DISCUSSION }

type Post
@model
@searchable
@auth(rules: [
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
  { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
  { allow: private, provider: iam, operations: [read] } # SSR & OpenSearch queries via IAM
])
@index(name: "bySlug", fields: ["slug"], queryField: "postBySlug") {
  id: ID!
  owner: String!
  type: PostType!
  title: String!
  slug: String!
  contentMD: String!
  tags: [String!]!
  score: Int!
  answersCount: Int!
  acceptedAnswerId: ID
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  # LOGGING HOOK: On create/update, write ActionLog (actor:"human", action:"post_created"/"post_updated")
}

type Answer
@model
@auth(rules: [
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
  { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
  { allow: private, provider: iam, operations: [read] } # SSR can read answers by IAM
])
@index(name: "byPost", fields: ["postId", "createdAt"]) {
  id: ID!
  owner: String!
  postId: ID!
  contentMD: String!
  score: Int!
  isAccepted: Boolean!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  # LOGGING HOOK: On create, ActionLog (actor:"human", action:"answer_submitted")
  # STREAM HOOK: acceptAnswerTrigger syncs Post.acceptedAnswerId + reputation
}

type Comment
@model
@auth(rules: [
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
  { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
  { allow: private, provider: iam, operations: [read] }
])
@index(name: "byParent", fields: ["parentType", "parentId", "createdAt"]) {
  id: ID!
  owner: String!
  parentType: String!  # "POST" | "ANSWER"
  parentId: ID!
  contentMD: String!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  # LOGGING HOOK: On create, ActionLog (actor:"human", action:"comment_added")
}

type Vote
@model(subscriptions: { level: off })
@auth(rules: [
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
  { allow: groups, groups: ["admin", "Admins"], operations: [read] }
])
@index(name: "byTarget", fields: ["targetType", "targetId", "owner"]) {
  id: ID!
  owner: String!
  targetType: String! # "POST" | "ANSWER"
  targetId: ID!
  value: Int!         # +1 or -1
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  # LOGGING HOOK: On write, ActionLog (actor:"human", action:"vote_cast", details:{targetType,targetId,value})
  # STREAM TRIGGER: voteReputationTrigger adjusts Post/Answer.score + UserProfile reputation
}

type Report
@model
@auth(rules: [
  { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create] },
  { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
])
@index(name: "byTarget", fields: ["targetType", "targetId", "createdAt"]) {
  id: ID!
  owner: String!
  targetType: String!  # "POST" | "ANSWER" | "COMMENT"
  targetId: ID!
  reason: String!
  createdAt: AWSDateTime
  # LOGGING HOOK: On create, ActionLog (actor:"human", action:"content_reported")
}

############################
# Convenience Inputs (optional)
############################

# If you later add custom mutations, these can be reused by Lambdas via IAM
input CreateNightlyRateInput {
  unitID: ID!, date: AWSDate!, state: String!, price: Float!, reason: String, details: AWSJSON, owner: String!
}

input CreateActionLogInput {
  unitID: ID!, actor: String!, action: String!, reason: String, details: AWSJSON, createdAt: AWSDateTime!, owner: String!
}
