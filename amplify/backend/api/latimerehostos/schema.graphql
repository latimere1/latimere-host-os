##############################################################################
# Latimere Host OS — GraphQL schema (Valid for Amplify push)
# - Core Property / Unit / Booking graph
# - Cleaning + CleanerAffiliation + Invitations
# - Inbox email graph
# - Referral graph for realtor → host onboarding pipeline
# - Autopilot v0 graph + Decision Log
# - IAM + public(apiKey) access where needed for workers and Next.js backend
##############################################################################

############################
# Core Property Graph
############################

type Property
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers read properties
  ]) {
  id: ID!
  name: String!
  address: String!
  sleeps: Int!
  owner: String!

  units: [Unit] @hasMany(indexName: "byProperty", fields: ["id"])

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Unit
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers read units
  ]) {
  id: ID!
  name: String!
  sleeps: Int!
  price: Float
  icalURL: String
  owner: String!

  propertyID: ID! @index(name: "byProperty", sortKeyFields: ["name"])
  bookings: [Booking] @hasMany(indexName: "byUnit", fields: ["id"])

  # --- Autopilot-friendly metadata (optional) ---
  timezone: String
  bedrooms: Int
  bathrooms: Float
  baseRate: Float
  minStay: Int

  # References to Policy records for this unit
  policies: [PolicyRef]

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Booking
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers read bookings
  ]) {
  id: ID!
  guestName: String
  checkIn: AWSDate!
  checkOut: AWSDate!
  payout: Float
  owner: String!

  unitID: ID! @index(name: "byUnit", sortKeyFields: ["checkIn"])

  # --- Helpful for Autopilot routing/metrics (optional) ---
  channel: String        # airbnb|direct|vrbo
  status: String         # confirmed|cancelled|hold
  guestEmail: AWSEmail

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Cleaning
  @model
  @auth(rules: [
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: owner, ownerField: "assignedTo", identityClaim: "cognito:username", operations: [read, update] },
    { allow: private, provider: iam, operations: [read, update] } # workers may update status
  ]) {
  id: ID!
  unitID: ID!
  date: AWSDateTime!
  status: String!
  assignedTo: String!
  notes: String
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type UserProfile
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
  ]) {
  id: ID!
  username: String!
  role: String!
  hasPaid: Boolean!
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type RevenueRecord
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers read revenue baselines
  ]) {
  id: ID!
  unitID: ID!
  amount: Float!
  month: String!
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type CleanerAffiliation
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
  ]) {
  id: ID!
  owner: String! @index(name: "byOwner", queryField: "listAffiliationsByOwner")
  cleanerUsername: String! @index(name: "byCleaner", queryField: "listAffiliationsByCleaner")
  cleanerDisplay: String
  status: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Invitation
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
  ]) {
  id: ID!
  owner: String! @index(name: "byOwnerInvites", queryField: "listInvitationsByOwner")
  email: String! @index(name: "byEmailInvites", queryField: "listInvitationsByEmail")
  role: String!
  tokenHash: String!
  status: String!
  lastSentAt: AWSDateTime
  expiresAt: AWSDateTime!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

############################
# Inbox / Email Graph
############################

type InboxThread
  @model(
    queries: { get: "getInboxThread", list: "listInboxThreads" }
    mutations: { create: "createInboxThread", update: "updateInboxThread", delete: "deleteInboxThread" }
  )
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read, update] } # Lambda workers only
  ]) {
  id: ID!
  maskedEmail: String! @index(name: "byMaskedEmail", queryField: "inboxThreadsByMaskedEmail")
  subject: String
  lastMessageAt: AWSDateTime
  messages: [InboxMessage] @hasMany(indexName: "byThread", fields: ["id"])

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type InboxMessage
  @model(
    queries: { get: "getInboxMessage", list: "listInboxMessages" }
    mutations: { create: "createInboxMessage", update: "updateInboxMessage", delete: "deleteInboxMessage" }
    subscriptions: null
  )
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read] } # Lambda workers only
  ]) {
  id: ID!
  threadId: ID! @index(name: "byThread", sortKeyFields: ["createdAt"])
  from: String
  to: String
  subject: String
  body: String
  messageId: String

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

############################
# Referral Graph (Realtor → Host Onboarding)
############################

# Core referral object backing:
# - /refer (realtor form)
# - /api/referrals/create (Next.js API route using API key)
# - /onboarding/<inviteToken> (owner onboarding entrypoint)
#
# Logging / diagnostics are supported by:
# - onboardingStatus
# - lastEmailSentAt / lastEmailStatus / lastEmailMessageId
# - debugContext (AWSJSON blob for pipeline debugging / logging)

type Referral
  @model
  @auth(rules: [
    # Admins can see/do everything
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },

    # Future: if realtors are Cognito users, they can see their own referrals
    { allow: owner, ownerField: "realtorSub", identityClaim: "sub", operations: [create, read, update] },

    # Workers (Lambdas, Step Functions) via IAM
    { allow: private, provider: iam, operations: [create, read, update, delete] },

    # API key (used by your Next.js backend; NOT from the browser directly)
    # Enables create + read + update for /api/referrals/* calls using x-api-key
    { allow: public, provider: apiKey, operations: [create, read, update] }
  ]) {
  id: ID!

  # Realtor / referrer information
  realtorName: String!
  realtorEmail: AWSEmail!
  realtorSub: String       # optional Cognito subject for future realtor login
  realtorAgency: String    # e.g. "eXp", "Keller Williams"

  # Potential host / client
  clientName: String!
  clientEmail: AWSEmail!

  # Optional freeform notes from the realtor
  notes: String

  # Where did this referral originate (realtor, website, direct, etc.)
  source: String @index(name: "bySource", queryField: "referralsBySource")

  # Lookups for reporting/debugging
  realtorEmailIndex: AWSEmail
    @index(name: "byRealtorEmail", queryField: "referralsByRealtorEmail")
  clientEmailIndex: AWSEmail
    @index(name: "byClientEmail", queryField: "referralsByClientEmail")

  # Invite + onboarding lifecycle
  inviteToken: String! @index(name: "byInviteToken", queryField: "referralByInviteToken")
  onboardingStatus: String!
    @index(name: "byOnboardingStatus", queryField: "referralsByOnboardingStatus")
  # e.g. NEW | INVITED | STARTED | COMPLETED | ABANDONED

  # Email / communication diagnostics (for debugging SES + pipeline issues)
  lastEmailSentAt: AWSDateTime
  lastEmailStatus: String      # e.g. "success", "bounce", "complaint"
  lastEmailMessageId: String   # SES message id when available

  # Referral bonus tracking
  payoutEligible: Boolean!
  payoutSent: Boolean!
  payoutMethod: String         # "Venmo", "CashApp", "PayPal", etc.
  payoutReference: String      # transaction id / last 4 / note
  payoutMarkedAt: AWSDateTime  # when an admin marked this referral as paid

  # Debug blob for logging context (request ids, step-function runs, etc.)
  debugContext: AWSJSON

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

############################
# Autopilot v0 Graph
############################

# Lightweight reference so Unit can list its active policies without embedding all config
type PolicyRef {
  id: ID!
  type: String!
}

# Policy holds pricing/min-stay/gap-fill configs per Unit
type Policy
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers read policies
  ]) {
  id: ID!
  unitID: ID! @index(name: "byUnit", sortKeyFields: ["type"])
  type: String!          # pricing|min_stay|gap_fill|other
  config: AWSJSON!       # e.g. tiers, weekends, gap rules
  enabled: Boolean!
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# NightlyRate stores proposed/applied rates per unit per night
type NightlyRate
  @model
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read, update] }, # workers write/read
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [read] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
  ]) {
  id: ID!
  unitID: ID! @index(name: "byUnitDate", sortKeyFields: ["date"], queryField: "ratesByUnitDate")
  date: AWSDate!
  state: String!         # proposed|applied
  price: Float!
  reason: String         # short explanation (e.g., "leadTier:14 gap:2 weekend")
  details: AWSJSON       # full inputs for audit/logging
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# Turn = operational job for cleans (separate from existing Cleaning for Autopilot control)
type Turn
  @model
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read, update] }, # workers schedule/update
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] }
  ]) {
  id: ID!
  unitID: ID! @index(name: "byUnitStart", sortKeyFields: ["startDate"], queryField: "turnsByUnitStart")
  bookingId: ID
  startDate: AWSDateTime!
  endDate: AWSDateTime!
  status: String!            # scheduled|confirmed|in_progress|done|reclean_needed|cancelled
  assignedToVendorId: ID
  photos: [AWSURL!]
  notes: String
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# Vendor network entity for cleaners/handymen with basic scoring
type Vendor
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers select vendors
  ]) {
  id: ID!
  kind: String!               # cleaner|handyman
  name: String!
  phone: String
  score: Float                # on-time/quality blended
  costIndex: Float            # relative cost
  serviceAreas: [String!]     # zips/tags
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# Decision Log — every automated/human action with reason + details
# Use this for "logging statements" from Lambdas or Next.js API routes.
type ActionLog
  @model
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read] },     # workers write logs, services read
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [read] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, delete] }
  ]) {
  id: ID!
  unitID: ID! @index(name: "byUnitTime", sortKeyFields: ["createdAt"], queryField: "actionLogByUnitTime")
  actor: String!              # autopilot|human|system
  action: String!             # price_set|turn_assigned|msg_sent|...
  reason: String              # one-line why
  details: AWSJSON            # inputs/outputs snapshot for debugging
  createdAt: AWSDateTime!
  owner: String!
}

############################
# Convenience Inputs (for custom Lambdas/mutations)
############################

input CreateNightlyRateInput {
  unitID: ID!
  date: AWSDate!
  state: String!
  price: Float!
  reason: String
  details: AWSJSON
  owner: String!
}

input CreateActionLogInput {
  unitID: ID!
  actor: String!
  action: String!
  reason: String
  details: AWSJSON
  createdAt: AWSDateTime!
  owner: String!
}
