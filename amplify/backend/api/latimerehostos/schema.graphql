##############################################################################
# Latimere Host OS — GraphQL schema (Valid for Amplify push)
# - Core Property / Unit / Booking graph
# - Cleaning + CleanerAffiliation + Invitations
# - Inbox email graph
# - Referral graph for realtor → host onboarding pipeline
# - Autopilot v0 graph + Decision Log
# - Latimere Revenue Management graph (profiles, snapshots, audits)
# - IAM + public(apiKey) access where needed for workers and Next.js backend
##############################################################################

############################
# Core Property Graph
############################

type Property
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers read properties
  ]) {
  id: ID!
  name: String!
  address: String!
  sleeps: Int!
  owner: String!

  units: [Unit] @hasMany(indexName: "byProperty", fields: ["id"])

  # Revenue Management relationships
  revenueProfile: RevenueProfile @hasOne
  revenueSnapshots: [RevenueSnapshot] @hasMany(indexName: "byPropertyRevenueSnapshot", fields: ["id"])
  revenueAudits: [RevenueAudit] @hasMany(indexName: "byPropertyRevenueAudit", fields: ["id"])

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Unit
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers read units
  ]) {
  id: ID!
  name: String!
  sleeps: Int!
  price: Float
  icalURL: String
  owner: String!

  propertyID: ID! @index(name: "byProperty", sortKeyFields: ["name"])
  bookings: [Booking] @hasMany(indexName: "byUnit", fields: ["id"])

  # --- Autopilot-friendly metadata (optional) ---
  timezone: String
  bedrooms: Int
  bathrooms: Float
  baseRate: Float
  minStay: Int

  # References to Policy records for this unit
  policies: [PolicyRef]

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Booking
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers read bookings
  ]) {
  id: ID!
  guestName: String
  checkIn: AWSDate!
  checkOut: AWSDate!
  payout: Float
  owner: String!

  unitID: ID! @index(name: "byUnit", sortKeyFields: ["checkIn"])

  # --- Helpful for Autopilot routing/metrics (optional) ---
  channel: String        # airbnb|direct|vrbo
  status: String         # confirmed|cancelled|hold
  guestEmail: AWSEmail

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Cleaning
  @model
  @auth(rules: [
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: owner, ownerField: "assignedTo", identityClaim: "cognito:username", operations: [read, update] },
    { allow: private, provider: iam, operations: [read, update] } # workers may update status
  ]) {
  id: ID!
  unitID: ID!
  date: AWSDateTime!
  status: String!
  assignedTo: String!
  notes: String
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type UserProfile
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
  ]) {
  id: ID!
  username: String!
  role: String!
  hasPaid: Boolean!
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type RevenueRecord
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers read revenue baselines
  ]) {
  id: ID!
  unitID: ID!
  amount: Float!
  month: String!
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type CleanerAffiliation
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
  ]) {
  id: ID!
  owner: String! @index(name: "byOwner", queryField: "listAffiliationsByOwner")
  cleanerUsername: String! @index(name: "byCleaner", queryField: "listAffiliationsByCleaner")
  cleanerDisplay: String
  status: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Invitation
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
  ]) {
  id: ID!
  owner: String! @index(name: "byOwnerInvites", queryField: "listInvitationsByOwner")
  email: String! @index(name: "byEmailInvites", queryField: "listInvitationsByEmail")
  role: String!
  tokenHash: String!
  status: String!
  lastSentAt: AWSDateTime
  expiresAt: AWSDateTime!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

############################
# Inbox / Email Graph
############################

type InboxThread
  @model(
    queries: { get: "getInboxThread", list: "listInboxThreads" }
    mutations: { create: "createInboxThread", update: "updateInboxThread", delete: "deleteInboxThread" }
  )
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read, update] } # Lambda workers only
  ]) {
  id: ID!
  maskedEmail: String! @index(name: "byMaskedEmail", queryField: "inboxThreadsByMaskedEmail")
  subject: String
  lastMessageAt: AWSDateTime
  messages: [InboxMessage] @hasMany(indexName: "byThread", fields: ["id"])

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type InboxMessage
  @model(
    queries: { get: "getInboxMessage", list: "listInboxMessages" }
    mutations: { create: "createInboxMessage", update: "updateInboxMessage", delete: "deleteInboxMessage" }
    subscriptions: null
  )
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read] } # Lambda workers only
  ]) {
  id: ID!
  threadId: ID! @index(name: "byThread", sortKeyFields: ["createdAt"])
  from: String
  to: String
  subject: String
  body: String
  messageId: String

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

############################
# Referral Graph (Realtor → Host Onboarding)
############################

# Core referral object backing:
# - /refer (realtor form)
# - /api/referrals/create (Next.js API route using API key)
# - /api/referrals/complete (Next.js API route using API key & IAM workers)
# - /onboarding/<inviteToken> (owner onboarding entrypoint)
#
# Logging / diagnostics:
# - onboardingStatus
# - lastEmailSentAt / lastEmailStatus / lastEmailMessageId
# - debugContext (AWSJSON blob for pipeline debugging / logging)

type Referral
  @model
  @auth(rules: [
    # Admins can see/do everything
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },

    # Future: if realtors are Cognito users, they can see their own referrals
    { allow: owner, ownerField: "realtorSub", identityClaim: "sub", operations: [create, read, update] },

    # Workers (Lambdas, Step Functions) via IAM
    { allow: private, provider: iam, operations: [create, read, update, delete] },

    # API key (used by your Next.js backend; NOT from the browser directly)
    # Enables create + read + update for /api/referrals/* calls using x-api-key
    { allow: public, provider: apiKey, operations: [create, read, update] }
  ]) {
  id: ID!

  # Realtor / referrer information
  realtorName: String!
  realtorEmail: AWSEmail!
  realtorSub: String       # optional Cognito subject for future realtor login
  realtorAgency: String    # e.g. "eXp", "Keller Williams"

  # Potential host / client
  clientName: String!
  clientEmail: AWSEmail!

  # Optional freeform notes from the realtor
  notes: String

  # Where did this referral originate (realtor, website, direct, etc.)
  source: String @index(name: "bySource", queryField: "referralsBySource")

  # Lookups for reporting/debugging
  realtorEmailIndex: AWSEmail
    @index(name: "byRealtorEmail", queryField: "referralsByRealtorEmail")
  clientEmailIndex: AWSEmail
    @index(name: "byClientEmail", queryField: "referralsByClientEmail")

  # Invite + onboarding lifecycle
  inviteToken: String! @index(name: "byInviteToken", queryField: "referralByInviteToken")
  onboardingStatus: String!
    @index(name: "byOnboardingStatus", queryField: "referralsByOnboardingStatus")
  # e.g. NEW | INVITED | STARTED | COMPLETED | ABANDONED

  # Email / communication diagnostics (for debugging SES + pipeline issues)
  lastEmailSentAt: AWSDateTime
  lastEmailStatus: String      # e.g. "success", "bounce", "complaint"
  lastEmailMessageId: String   # SES message id when available

  # Referral bonus tracking
  payoutEligible: Boolean!
  payoutSent: Boolean!
  payoutMethod: String         # "Venmo", "CashApp", "PayPal", etc.
  payoutReference: String      # transaction id / last 4 / note
  payoutMarkedAt: AWSDateTime  # when an admin marked this referral as paid

  # Debug blob for logging context (request ids, step-function runs, etc.)
  debugContext: AWSJSON

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

############################
# Autopilot v0 Graph
############################

# Lightweight reference so Unit can list its active policies without embedding all config
type PolicyRef {
  id: ID!
  type: String!
}

# Policy holds pricing/min-stay/gap-fill configs per Unit
type Policy
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers read policies
  ]) {
  id: ID!
  unitID: ID! @index(name: "byUnit", sortKeyFields: ["type"])
  type: String!          # pricing|min_stay|gap_fill|other
  config: AWSJSON!       # e.g. tiers, weekends, gap rules
  enabled: Boolean!
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# NightlyRate stores proposed/applied rates per unit per night
type NightlyRate
  @model
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read, update] }, # workers write/read
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [read] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
  ]) {
  id: ID!
  unitID: ID! @index(name: "byUnitDate", sortKeyFields: ["date"], queryField: "ratesByUnitDate")
  date: AWSDate!
  state: String!         # proposed|applied
  price: Float!
  reason: String         # short explanation (e.g., "leadTier:14 gap:2 weekend")
  details: AWSJSON       # full inputs for audit/logging
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# Turn = operational job for cleans (separate from existing Cleaning for Autopilot control)
type Turn
  @model
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read, update] }, # workers schedule/update
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] }
  ]) {
  id: ID!
  unitID: ID! @index(name: "byUnitStart", sortKeyFields: ["startDate"], queryField: "turnsByUnitStart")
  bookingId: ID
  startDate: AWSDateTime!
  endDate: AWSDateTime!
  status: String!            # scheduled|confirmed|in_progress|done|reclean_needed|cancelled
  assignedToVendorId: ID
  photos: [AWSURL!]
  notes: String
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# Vendor network entity for cleaners/handymen with basic scoring
type Vendor
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers select vendors
  ]) {
  id: ID!
  kind: String!               # cleaner|handyman
  name: String!
  phone: String
  score: Float                # on-time/quality blended
  costIndex: Float            # relative cost
  serviceAreas: [String!]     # zips/tags
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# Decision Log — every automated/human action with reason + details
# Use this from Lambdas or Next.js API routes as your "logging statements".
type ActionLog
  @model
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read] },     # workers write logs, services read
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [read] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, delete] }
  ]) {
  id: ID!
  unitID: ID! @index(name: "byUnitTime", sortKeyFields: ["createdAt"], queryField: "actionLogByUnitTime")
  actor: String!              # autopilot|human|system
  action: String!             # price_set|turn_assigned|msg_sent|...
  reason: String              # one-line why
  details: AWSJSON            # inputs/outputs snapshot for debugging
  createdAt: AWSDateTime!
  owner: String!
}

############################
# Convenience Inputs (for custom Lambdas/mutations)
############################

input CreateNightlyRateInput {
  unitID: ID!
  date: AWSDate!
  state: String!
  price: Float!
  reason: String
  details: AWSJSON
  owner: String!
}

input CreateActionLogInput {
  unitID: ID!
  actor: String!
  action: String!
  reason: String
  details: AWSJSON
  createdAt: AWSDateTime!
  owner: String!
}

############################
# Latimere Revenue Management — Core Models
############################

enum RevenueTier {
  ESSENTIAL
  PRO
  ELITE
}

enum PricingCadence {
  WEEKLY
  DAILY
}

# Per-property configuration for Latimere Revenue Management
type RevenueProfile
  @model
  @auth(rules: [
    # Property owner can see/update their own profile
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    # Admins can fully manage
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    # IAM workers can read for reporting automations
    { allow: private, provider: iam, operations: [read] },
    # Next.js backend / admin UI via x-api-key
    { allow: public, provider: apiKey, operations: [create, read, update] }
  ]) {
  id: ID!
  propertyId: ID! @index(name: "byPropertyRevenueProfile", sortKeyFields: ["createdAt"])
  property: Property @belongsTo(fields: ["propertyId"])

  owner: String!                         # Same pattern as Property.owner

  tier: RevenueTier!
  pricingCadence: PricingCadence!        # Weekly vs daily pricing work
  isActive: Boolean!                     # If Latimere is currently managing revenue

  # Core config knobs
  baseNightlyRate: Float                 # Default base price you anchor from
  targetOccupancyPct: Int                # e.g., 70
  marketName: String                     # e.g., "Smoky Mountains - 3BR Cabins"
  notes: String                          # Freeform config notes (JSON or text)

  # Admin-only fields
  internalLabel: String                  # e.g., "Cabin 1 – Pro Tier"
  internalOwnerEmail: AWSEmail           # Owner’s primary contact email

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# Monthly/period revenue metrics used for dashboards + reports
type RevenueSnapshot
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] },
    # Next.js backend / admin UI via x-api-key (for dashboards + emails)
    { allow: public, provider: apiKey, operations: [create, read, update] }
  ]) {
  id: ID!
  propertyId: ID! @index(name: "byPropertyRevenueSnapshot", sortKeyFields: ["periodStart"])
  property: Property @belongsTo(fields: ["propertyId"])

  owner: String!

  # Period this snapshot represents (monthly for MVP)
  periodStart: AWSDate!                  # e.g., "2025-11-01"
  periodEnd: AWSDate!                    # e.g., "2025-11-30"
  label: String                          # e.g., "November 2025"

  # Core metrics (dashboard)
  grossRevenue: Float                    # Total gross revenue
  occupancyPct: Float                    # Occupancy %
  adr: Float                             # Average Daily Rate
  nightsBooked: Int
  nightsAvailable: Int

  # Market comparison (from AirDNA/Rabbu)
  marketOccupancyPct: Float
  marketAdr: Float
  marketSampleSize: Int                  # e.g., 50 comps

  # Forward-looking (next 90 days)
  future30Revenue: Float
  future60Revenue: Float
  future90Revenue: Float

  # Fees / cancellations
  cleaningFeesCollected: Float
  cancellationsCount: Int
  cancellationRevenueLost: Float

  # Reporting & links
  revenueReportUrl: AWSURL               # Link to Canva/Slides PDF
  dashboardUrl: AWSURL                   # Data Studio / Looker link if used

  # High-level narrative for the month
  keyInsights: String                    # e.g., "Raised prices 10%, occupancy flat..."
  pricingDecisionsSummary: String        # Summary of key actions taken this month

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# One-off or ad-hoc revenue audits (lead magnet)
type RevenueAudit
  @model
  @auth(rules: [
    # Owner = Latimere account that runs the audit
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] },
    # Public create via x-api-key from Next.js API (free revenue audit form)
    { allow: public, provider: apiKey, operations: [create] }
  ]) {
  id: ID!

  # If this audit is linked to a property in Latimere Host OS
  propertyId: ID @index(name: "byPropertyRevenueAudit", sortKeyFields: ["createdAt"])
  property: Property @belongsTo(fields: ["propertyId"])

  owner: String!                         # The Latimere account owner running the audit ("latimere-intake" or a specific user)

  # Lead info (could be non-Latimere client yet)
  ownerName: String
  ownerEmail: AWSEmail
  listingUrl: AWSURL                     # Airbnb/VRBO listing URL
  marketName: String

  # Key audit outputs (10-min quick look)
  estimatedAnnualRevenueCurrent: Float
  estimatedAnnualRevenueOptimized: Float
  projectedGainPct: Float                # (optimized - current)/current * 100

  underpricingIssues: String             # e.g., JSON or bulleted text
  competitorSummary: String              # Short comp comparison (3 comps)
  recommendations: String                # Quick recommendations text (also used as intake blob)

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}
