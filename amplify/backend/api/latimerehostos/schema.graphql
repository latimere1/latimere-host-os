##############################################################################
# Latimere Host OS — GraphQL schema (Valid for Amplify push)
# - Core Property / Unit / Booking graph
# - Cleaning + CleanerAffiliation + Invitations
# - Inbox email graph
# - Referral graph for realtor/partner → host onboarding pipeline
# - ReferralPartner registry + referralCode support
# - Autopilot v0 graph + ActionLog (central logging)
# - Latimere Revenue Management graph (profiles, snapshots, audits)
# - IAM + public(apiKey) access where needed for workers and Next.js backend
##############################################################################

############################
# Core Property Graph
############################

type Property
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] }, # workers read properties
    # Admin UI / Next.js backend via API key (read-only)
    { allow: public, provider: apiKey, operations: [read] }
  ]) {
  id: ID!
  name: String!
  nickname: String
  address: String!
  city: String
  state: String
  country: String
  sleeps: Int!
  owner: String!

  units: [Unit] @hasMany(indexName: "byProperty", fields: ["id"])

  # Revenue Management relationships
  revenueProfile: RevenueProfile @hasOne
  revenueSnapshots: [RevenueSnapshot] @hasMany(indexName: "byPropertyRevenueSnapshot", fields: ["id"])
  revenueAudits: [RevenueAudit] @hasMany(indexName: "byPropertyRevenueAudit", fields: ["id"])

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Unit
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers read units
  ]) {
  id: ID!
  name: String!
  sleeps: Int!
  price: Float
  icalURL: String
  owner: String!

  propertyID: ID! @index(name: "byProperty", sortKeyFields: ["name"])
  bookings: [Booking] @hasMany(indexName: "byUnit", fields: ["id"])

  # --- Autopilot-friendly metadata (optional) ---
  timezone: String
  bedrooms: Int
  bathrooms: Float
  baseRate: Float
  minStay: Int

  # References to Policy records for this unit
  policies: [PolicyRef]

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Booking
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers read bookings
  ]) {
  id: ID!
  guestName: String
  checkIn: AWSDate!
  checkOut: AWSDate!
  payout: Float
  owner: String!

  unitID: ID! @index(name: "byUnit", sortKeyFields: ["checkIn"])

  # --- Helpful for Autopilot routing/metrics (optional) ---
  channel: String        # airbnb|direct|vrbo
  status: String         # confirmed|cancelled|hold
  guestEmail: AWSEmail

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Cleaning
  @model
  @auth(rules: [
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: owner, ownerField: "assignedTo", identityClaim: "cognito:username", operations: [read, update] },
    { allow: private, provider: iam, operations: [read, update] } # workers may update status
  ]) {
  id: ID!
  unitID: ID!
  date: AWSDateTime!
  status: String!
  assignedTo: String!
  notes: String
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type UserProfile
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
  ]) {
  id: ID!
  username: String!
  role: String!
  hasPaid: Boolean!
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type RevenueRecord
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers read revenue baselines
  ]) {
  id: ID!
  unitID: ID!
  amount: Float!
  month: String!
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type CleanerAffiliation
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
  ]) {
  id: ID!
  owner: String! @index(name: "byOwner", queryField: "listAffiliationsByOwner")
  cleanerUsername: String! @index(name: "byCleaner", queryField: "listAffiliationsByCleaner")
  cleanerDisplay: String
  status: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type Invitation
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
  ]) {
  id: ID!
  owner: String! @index(name: "byOwnerInvites", queryField: "listInvitationsByOwner")
  email: String! @index(name: "byEmailInvites", queryField: "listInvitationsByEmail")
  role: String!
  tokenHash: String!
  status: String!
  lastSentAt: AWSDateTime
  expiresAt: AWSDateTime!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

############################
# Inbox / Email Graph
############################

type InboxThread
  @model(
    queries: { get: "getInboxThread", list: "listInboxThreads" }
    mutations: { create: "createInboxThread", update: "updateInboxThread", delete: "deleteInboxThread" }
  )
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read, update] } # Lambda workers only
  ]) {
  id: ID!
  maskedEmail: String! @index(name: "byMaskedEmail", queryField: "inboxThreadsByMaskedEmail")
  subject: String
  lastMessageAt: AWSDateTime
  messages: [InboxMessage] @hasMany(indexName: "byThread", fields: ["id"])

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

type InboxMessage
  @model(
    queries: { get: "getInboxMessage", list: "listInboxMessages" }
    mutations: { create: "createInboxMessage", update: "updateInboxMessage", delete: "deleteInboxMessage" }
    subscriptions: null
  )
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read] } # Lambda workers only
  ]) {
  id: ID!
  threadId: ID! @index(name: "byThread", sortKeyFields: ["createdAt"])
  from: String
  to: String
  subject: String
  body: String
  messageId: String

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

############################
# Referral Graph (Realtor / Partner → Host Onboarding)
############################

# Core referral object backing:
# - /refer (realtor/partner form)
# - /api/referrals/create (Next.js API route using API key)
# - /api/referrals/complete (Next.js API route using API key & IAM workers)
# - /onboarding/<inviteToken> (owner onboarding entrypoint)
#
# Logging / diagnostics:
# - onboardingStatus + lastStatus* fields
# - lastEmailSentAt / lastEmailStatus / lastEmailMessageId
# - debugContext (AWSJSON blob for pipeline debugging / logging)
# - referralCode + partnerId hook into ReferralPartner + ActionLog

type Referral
  @model
  @auth(rules: [
    # Admins can see/do everything
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },

    # Future: if realtors are Cognito users, they can see their own referrals
    { allow: owner, ownerField: "realtorSub", identityClaim: "sub", operations: [create, read, update] },

    # Workers (Lambdas, Step Functions) via IAM
    { allow: private, provider: iam, operations: [create, read, update, delete] },

    # API key (used by your Next.js backend; NOT from the browser directly)
    # Enables create + read + update for /api/referrals/* calls using x-api-key
    { allow: public, provider: apiKey, operations: [create, read, update] }
  ]) {
  id: ID!

  # Realtor / referrer information
  realtorName: String!
  realtorEmail: AWSEmail!
  realtorSub: String       # optional Cognito subject for future realtor login
  realtorAgency: String    # e.g. "eXp", "Keller Williams"

  # Potential host / client
  clientName: String!
  clientEmail: AWSEmail!

  # Optional freeform notes from the referrer
  notes: String

  # High-level origin (realtor, cleaner, business, website, direct, etc.)
  source: String @index(name: "bySource", queryField: "referralsBySource")

  # Optional partner linkage (for non-realtor business partners)
  partnerId: ID @index(name: "byPartner", queryField: "referralsByPartner")

  # Referral code used for this referral (tracks business partners, signs, QR codes, etc.)
  referralCode: String
    @index(name: "byReferralCode", queryField: "referralsByReferralCode")

  # Lookups for reporting/debugging
  realtorEmailIndex: AWSEmail
    @index(name: "byRealtorEmail", queryField: "referralsByRealtorEmail")
  clientEmailIndex: AWSEmail
    @index(name: "byClientEmail", queryField: "referralsByClientEmail")

  # Invite + onboarding lifecycle
  inviteToken: String! @index(name: "byInviteToken", queryField: "referralByInviteToken")
  onboardingStatus: String!
    @index(name: "byOnboardingStatus", queryField: "referralsByOnboardingStatus")
  # e.g. NEW | INVITED | STARTED | COMPLETED | ABANDONED

  # Lightweight status-change audit for debugging
  lastStatusChangedAt: AWSDateTime
  lastStatusChangedBy: String        # e.g. "lambda:referrals-complete", "admin:taylor"
  lastStatusChangeReason: String     # human-readable explanation

  # Email / communication diagnostics (for debugging SES + pipeline issues)
  lastEmailSentAt: AWSDateTime
  lastEmailStatus: String      # e.g. "success", "bounce", "complaint"
  lastEmailMessageId: String   # SES message id when available

  # Referral bonus tracking
  payoutEligible: Boolean!
  payoutSent: Boolean!
  payoutMethod: String         # "Venmo", "CashApp", "PayPal", etc.
  payoutReference: String      # transaction id / last 4 / note
  payoutMarkedAt: AWSDateTime  # when an admin marked this referral as paid

  # Debug blob for logging context (request ids, step-function runs, etc.)
  debugContext: AWSJSON

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# Registry of referral partners (realtors, cleaners, businesses, etc.)
# Gives you a canonical place to manage referral codes and payouts.

type ReferralPartner
  @model
  @auth(rules: [
    # Admins own/maintain the partner registry
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },

    # Workers can read + update counters via IAM
    { allow: private, provider: iam, operations: [read, update] },

    # Next.js backend / admin UI via x-api-key
    { allow: public, provider: apiKey, operations: [create, read, update] }
  ]) {
  id: ID!

  # Display + classification
  name: String!                 # e.g., "Dustan's Cleaning", "Smoky Realty Group"
  type: String                  # cleaner|realtor|business|loan_officer|other

  # Contact details (optional but useful)
  contactName: String
  contactEmail: AWSEmail
  contactPhone: String

  # Unique referral code for this partner (used on signs/QR links/etc.)
  referralCode: String!
    @index(name: "byReferralCodePartner", queryField: "referralPartnerByCode")

  # Whether we consider this partner active
  active: Boolean!

  # Basic stats (can be updated by workers or admin UI)
  totalReferrals: Int
  totalPayouts: Int

  notes: String                 # any internal notes about this partner

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

############################
# Autopilot v0 Graph
############################

# Lightweight reference so Unit can list its active policies without embedding all config
type PolicyRef {
  id: ID!
  type: String!
}

# Policy holds pricing/min-stay/gap-fill configs per Unit
type Policy
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers read policies
  ]) {
  id: ID!
  unitID: ID! @index(name: "byUnit", sortKeyFields: ["type"])
  type: String!          # pricing|min_stay|gap_fill|other
  config: AWSJSON!       # e.g. tiers, weekends, gap rules
  enabled: Boolean!
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# NightlyRate stores proposed/applied rates per unit per night
type NightlyRate
  @model
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read, update] }, # workers write/read
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [read] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, update, delete] }
  ]) {
  id: ID!
  unitID: ID! @index(name: "byUnitDate", sortKeyFields: ["date"], queryField: "ratesByUnitDate")
  date: AWSDate!
  state: String!         # proposed|applied
  price: Float!
  reason: String         # short explanation (e.g., "leadTier:14 gap:2 weekend")
  details: AWSJSON       # full inputs for audit/logging
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# Turn = operational job for cleans (separate from existing Cleaning for Autopilot control)
type Turn
  @model
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read, update] }, # workers schedule/update
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] }
  ]) {
  id: ID!
  unitID: ID! @index(name: "byUnitStart", sortKeyFields: ["startDate"], queryField: "turnsByUnitStart")
  bookingId: ID
  startDate: AWSDateTime!
  endDate: AWSDateTime!
  status: String!            # scheduled|confirmed|in_progress|done|reclean_needed|cancelled
  assignedToVendorId: ID
  photos: [AWSURL!]
  notes: String
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# Vendor network entity for cleaners/handymen with basic scoring
type Vendor
  @model
  @auth(rules: [
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] } # workers select vendors
  ]) {
  id: ID!
  kind: String!               # cleaner|handyman
  name: String!
  phone: String
  score: Float                # on-time/quality blended
  costIndex: Float            # relative cost
  serviceAreas: [String!]     # zips/tags
  owner: String!

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# Decision Log — every automated/human action with reason + details.
# Use this from Lambdas or Next.js API routes as your "logging statements".

type ActionLog
  @model
  @auth(rules: [
    { allow: private, provider: iam, operations: [create, read] },     # workers write logs, services read
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [read] },
    { allow: groups, groups: ["admin", "Admins"], operations: [read, delete] }
  ]) {
  id: ID!

  # Primary association is to a Unit for Autopilot + pricing logs
  unitID: ID @index(name: "byUnitTime", sortKeyFields: ["createdAt"], queryField: "actionLogByUnitTime")

  # Optional linkage to a Referral so you can log referral lifecycle events
  referralId: ID @index(name: "byReferralTime", sortKeyFields: ["createdAt"], queryField: "actionLogByReferralTime")

  actor: String!              # autopilot|human|system|lambda:referrals-create
  action: String!             # price_set|turn_assigned|msg_sent|referral_created|referral_payout_marked|...
  reason: String              # one-line why
  details: AWSJSON            # inputs/outputs snapshot for debugging
  createdAt: AWSDateTime!
  owner: String!
}

############################
# Convenience Inputs (for custom Lambdas/mutations)
############################

input CreateNightlyRateInput {
  unitID: ID!
  date: AWSDate!
  state: String!
  price: Float!
  reason: String
  details: AWSJSON
  owner: String!
}

input CreateActionLogInput {
  unitID: ID
  referralId: ID
  actor: String!
  action: String!
  reason: String
  details: AWSJSON
  createdAt: AWSDateTime!
  owner: String!
}

############################
# Latimere Revenue Management — Core Models
############################

enum RevenueTier {
  ESSENTIAL
  PRO
  ELITE
}

enum PricingCadence {
  WEEKLY
  DAILY
}

# Per-property configuration for Latimere Revenue Management

type RevenueProfile
  @model
  @auth(rules: [
    # Property owner can see/update their own profile
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    # Admins can fully manage
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    # IAM workers can read for reporting automations
    { allow: private, provider: iam, operations: [read] },
    # Next.js backend / admin UI via x-api-key
    { allow: public, provider: apiKey, operations: [create, read, update] }
  ]) {
  id: ID!
  propertyId: ID! @index(name: "byPropertyRevenueProfile", sortKeyFields: ["createdAt"])
  property: Property @belongsTo(fields: ["propertyId"])

  owner: String!                         # Same pattern as Property.owner

  tier: RevenueTier!
  pricingCadence: PricingCadence!        # Weekly vs daily pricing work
  isActive: Boolean!                     # If Latimere is currently managing revenue

  # Core config knobs
  baseNightlyRate: Float                 # Default base price you anchor from
  targetOccupancyPct: Int                # e.g., 70
  marketName: String                     # e.g., "Smoky Mountains - 3BR Cabins"
  notes: String                          # Freeform config notes (JSON or text)

  # Admin-only fields
  internalLabel: String                  # e.g., "Cabin 1 – Pro Tier"
  internalOwnerEmail: AWSEmail           # Owner’s primary contact email

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# Monthly/period revenue metrics used for dashboards + reports

type RevenueSnapshot
  @model
  @auth(rules: [
    # Property owner can see/update their own snapshots
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    # Admins manage everything
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    # Workers (Lambdas) read for reporting / emails
    { allow: private, provider: iam, operations: [read] },
    # Next.js backend / admin UI via x-api-key (dashboards + emails)
    { allow: public, provider: apiKey, operations: [create, read, update] }
  ]) {
  id: ID!
  propertyId: ID! @index(name: "byPropertyRevenueSnapshot", sortKeyFields: ["periodStart"])
  property: Property @belongsTo(fields: ["propertyId"])

  owner: String!

  # Period this snapshot represents (monthly for MVP)
  periodStart: AWSDate!                  # e.g., "2025-11-01"
  periodEnd: AWSDate!                    # e.g., "2025-11-30"
  label: String                          # e.g., "November 2025"

  # Core metrics (dashboard)
  grossRevenue: Float                    # Total gross revenue
  occupancyPct: Float                    # Occupancy %
  adr: Float                             # Average Daily Rate
  nightsBooked: Int
  nightsAvailable: Int

  # Market comparison (from AirDNA/Rabbu)
  marketOccupancyPct: Float
  marketAdr: Float
  marketSampleSize: Int                  # e.g., 50 comps

  # Forward-looking (next 90 days)
  future30Revenue: Float
  future60Revenue: Float
  future90Revenue: Float

  # Fees / cancellations
  cleaningFeesCollected: Float
  cancellationsCount: Int
  cancellationRevenueLost: Float

  # Reporting & links
  revenueReportUrl: AWSURL               # Link to Canva/Slides PDF
  dashboardUrl: AWSURL                   # Data Studio / Looker link if used

  # High-level narrative for the month
  keyInsights: String                    # e.g., "Raised prices 10%, occupancy flat..."
  pricingDecisionsSummary: String        # Summary of key actions taken this month

  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

# One-off or ad-hoc revenue audits (lead magnet)

type RevenueAudit
  @model
  @auth(rules: [
    # Owner = Latimere account that runs the audit
    { allow: owner, ownerField: "owner", identityClaim: "sub", operations: [create, read, update, delete] },
    { allow: groups, groups: ["admin", "Admins"], operations: [create, read, update, delete] },
    { allow: private, provider: iam, operations: [read] },
    # Public create/read/update via x-api-key from Next.js (form + admin UI)
    { allow: public, provider: apiKey, operations: [create, read, update] }
  ]) {
  id: ID!

  # propertyId is required – it’s the partition key and belongsTo field
  propertyId: ID! @index(name: "byPropertyRevenueAudit", sortKeyFields: ["createdAt"])
  property: Property @belongsTo(fields: ["propertyId"])

  owner: String! # used by the owner rule above

  ownerName: String
  ownerEmail: AWSEmail
  listingUrl: AWSURL
  marketName: String

  estimatedAnnualRevenueCurrent: Float
  estimatedAnnualRevenueOptimized: Float
  projectedGainPct: Float

  underpricingIssues: String
  competitorSummary: String
  recommendations: String

  # createdAt acts as sort key for byPropertyRevenueAudit
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}
